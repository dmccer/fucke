{
  "name": "next.js",
  "description": "a tiny library for callback style async programing",
  "version": "1.0.3",
  "homepage": "http://youngjay.github.com/next",
  "author": {
    "name": "Yang Jie",
    "email": "hiyoungjay@gmail.com"
  },
  "keywords": [
    "async",
    "callback"
  ],
  "main": "./index.js",
  "dist": {
    "shasum": "3fd980a7f98bb1081930aa35ef421245cb93f833"
  },
  "readme": "# next\r\n\r\nnext 是一个为callback风格的异步编程提供支持的工具库。\r\nnext和[Async.js](https://github.com/caolan/async)的不同之处在于：async是调用函数, next是生成函数\r\n\r\n\r\n\r\n## 优势\r\n* 函数复用--\r\n针对函数而不是针对过程，可以对函数进行组合和连接。采用node风格的callback机制，直接可以复用系统函数。\r\n\r\n* 扁平化callback层次--\r\n使用next.pipe(fn1, fn2, fnN)连接函数，扁平化callback层次。\r\n\r\n* 统一的异常处理--\r\n在pipe、map、parallel等方法中进行组合的函数，一旦发生异常，则会统一跳到运行时传入callback进行处理，不用重复判断每级的error。\r\n\r\n## API\r\n\r\n### pipe([fn1], [fn2], [fnN])\r\n生成一个函数，先调用fn1，完成之后以fn1的返回值调用fn2，以此类推。\r\n在调用的时候如果有异常，直接跳到运行时传入的callback\r\n\r\n```javascript\r\nvar add2 = next.pipe(\r\n  function(num, callback) { callback(null, num + 1, num + 2) },\r\n  function(num1, num2, callback) { callback(null, num1 + 3, num2 + 3) }\r\n);\r\n\r\nadd2(1, function() {\r\n  console.log(arguments);\r\n});\r\n\r\n// result: [null, 5, 6]\r\n```\r\n\r\n### map(fn)\r\n生成一个函数，遍历入参每一个元素，调用fn。收集完结果之后按照传入顺序返回。\r\n```javascript\r\nvar addEach = next.map(\r\n  function(num, callback) { callback(null, num + 1) }\r\n);\r\n\r\naddEach([1,2,3], function() {\r\n  console.log(arguments);\r\n});\r\n// result: [null, [2,3,4]]\r\n\r\n```\r\n\r\n### parallel(fn1, [fn2], [fnN])\r\n生成一个函数，以当前参数调用每个fn，收集结果之后返回\r\n```javascript\r\nvar parallelAction = next.parallel(\r\n  function(num, callback) { callback(null, num + 1) },\r\n  function(num, callback) { callback(null, num + 2) }\r\n);\r\n\r\nparallelAction(1, function() {\r\n  console.log(arguments);\r\n});\r\n// result: [null, 2,3]\r\n\r\n```\r\n\r\n### concurrency(fn, limit, [onDrain])\r\n生成一个函数，使得同时运行的fn不超过limit个，超过的调用将被缓存，当有fn执行完毕之后再执行。当所有的fn调用完毕时触发onDrain\r\n```javascript\r\nvar throttledRunner = next.concurrency(function(a, callback) {\r\n  console.log('start:' + a);\r\n  setTimeout(function() {\r\n    console.log('end:' + a);\r\n    callback(a);\r\n  }, Math.random() * 3000);\r\n}, 5, function() {\r\n  console.log('drain');\r\n});\r\n\r\nfor (var i = 0; i < 1000; i++) {\r\n  throttledRunner(i, function() {});\r\n}\r\n\r\n```\r\n\r\n### attempt([fn1], [fn2], [fnN])\r\n顺序尝试fn1到fnN，直到当有一个成功，返回值\r\nnext.attempt(\r\n  function(a, callback) {\r\n    callback(1);\r\n  }, \r\n  function(a, callback) {\r\n    callback(null, 2)\r\n  }, \r\n  function(a, callback) {\r\n    callback(3)\r\n  }\r\n)('error', function() {\r\n  console.log(arguments)\r\n})\r\n\r\n//result: [null, 2] \r\n\r\n```\r\n\r\n## 一些功能示例\r\n### [compress](https://github.com/youngjay/next/blob/master/examples/compress/compress.js)\r\n从页面上读取script标签src -> 获取js文件内容 -> 调用uglify-js压缩 -> 写文件\r\n\r\n",
  "readmeFilename": "README.md",
  "_id": "next.js@1.0.3",
  "_from": "next.js@~1"
}
